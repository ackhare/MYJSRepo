<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title></title>

    <script>
        //Consider this code:
                function foo() {
                    console.log( this.a );//same reult with a
                }

        var a = 2;

        foo(); // 2
//        The first thing to note, if you were not already aware, is that variables declared in the global scope, as var a = 2
//   is, are synonymous with global-object properties of the same name. They're not copies of each other, they are each
//   other. Think of it as two sides of the same coin. Secondly, we see that when foo() is called, this.a resolves to our
//   global variable a. Why? Because in this case, the default binding for this applies to the function call, and so
//   points this at the global object. How do we know that the default binding rule applies here? We examine the call-site
//   to see how foo() is called. In our snippet, foo() is called with a plain, un-decorated function reference. None of
//   the other rules we will demonstrate will apply here, so the default binding applies instead. If strict mode is in
//   effect, the global object is not eligible for the default binding, so the this is instead set to undefined.
//
//
    </script>
</head>
<body>

</body>
</html>